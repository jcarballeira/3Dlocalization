function[bestmem,error,poblacion,F,NP]=alg_genet_3D(dist_real_3d,cart_real_3d,Mapa_3D,poblacion,mapmax,mapmin,err_dis,num_medidas,num_barridos,incr_theta,NP,D,iter_max,F,CR,version_de,version_fitness,alpha)
%--------------------------------------------------------------------------
%   Main Function: alg_genet_3D
%   Author: Fernando Martin Monar.
%   Date: December, 2010
%--------------------------------------------------------------------------
% -> Description: Genetic algorithm that is executed to obtain the robot's
% location in a known map. The laser scan and the known map are used to
% estimate the robot's pose. The core engine is the DE algorithm and the
% cost value is generated by fitness_3d.m.
%--------------------------------------------------------------------------
% -> Inputs:
%       -dist_real_3d: Matrix with dimensions num_barridos*num_medidas
%       containing the distances of the laser measurements.
%       -cart_real_3d: Matrix with dimensions (num_barridos*num_medidas)*3
%       containing the 3D Cartesian coordinates of the laser measurements.
%       -Mapa_3D: Matrix that contains the 3D map of the environment.
%       -poblacion: population set. Matrix with dimensions NP*(D+1) where
%       each row contains a candidate with an associated cost value (first
%       column).
%       -mapmax: Vector of 4 elements that corresponds to the map size. The
%       first three coordinates are the map dimensions, in cartesian
%       coordinates, and the fourth one is the orientation, typically 360
%       degrees.
%       -mapmin: Minimum index in the map. Typically =[1,1,1,1].
%       -err_dis: Sensor noise, standard deviation, in percentage over the
%       distance weighted.
%       -num_medidas: Number of horizontal measurements.
%       -num_barridos: Number of vertical scans.
%       -incr_theta: Laser horizontal resolution.
%       -NP: population size.
%       -D: Number of chromosomes (DE parameter).
%       -iter_max: Maximum number of iterations.
%       -F: Differential variation factor. Mutation coefficient (DE param).
%       -CR: Crossover constant (DE parameter).
%       -version: Option of the DE algorithm selected via keyboard in
%       local_3D_real.m
% -> Outputs:
%       -bestmem: Vector of D+1 elements containing the solution of the
%       global localization filter (robot's location) and its cost value in
%       the first element.
%       -error: Cost value of the best candidate.
%       -poblacion: Population set after convergence or maximum iterations.
%       -F: mutation factor (it is varied in some options).
%       -NP: population size after convergence (it is varied in some
%       options).
%--------------------------------------------------------------------------
% -> See also: dist_est_3d fitness_3d
%--------------------------------------------------------------------------   

%Inicializamos variables
trial=zeros(1,D);
bestmem=zeros(1,D+1);
pob_aux=zeros(NP,D+1);
count_a=0; %contadores para la convergencia del algoritmo
count_b=0;
count_c=0;
count=1;
imp_count=1;

error_max=100000;
error=10000;
dif_errores=100000;

%Para la primera poblacion
for i=1:NP
    previo=[poblacion(i,2),poblacion(i,3),poblacion(i,4),poblacion(i,5)];
    %Calculamos el fitness antes de la mutación
    [dist_est_3d_previo,cart_est_3d_previo]=dist_est_3d(previo,Mapa_3D,mapmax,mapmin,err_dis,num_medidas,num_barridos,incr_theta);
    %evaluacion devuelve el error de las medidas para el punto perturbado
    poblacion(i,1)=fitness_3d(dist_real_3d, cart_real_3d, dist_est_3d_previo, cart_est_3d_previo,version_fitness,err_dis,alpha,num_medidas,num_barridos);
end
%--------------------------------------------------------------------------
while (count<=iter_max)%&&(error~=error_max)&&(error_max>error+10)%3*NP/2) %&&(error>NS/3))%%&&(count_c<30)&&((count_a<100)||(count_b<100)))
     %( (count<=iter_max)&&(error>150)&&(count_c<30)&&((count_a<100)||(count_b<100)))
    for i=1:NP

        %Se eligen aleatoriamente 3 vectores distintos de i
        a=random('unid',NP);
        while((a==i)||(a==0))
            a=random('unid',NP);
        end
        b=random('unid',NP);
        while((b==i)||(b==a)||(b==0))
            b=random('unid',NP);
        end
        c=random('unid',NP);
        while((c==i)||(c==a)||(c==b)||(c==0))
            c=random('unid',NP);
        end
        
        %MUTACION Y CRUCE
        for k=2:(D+1)
            cross_rand=random('unid',100);
            if(cross_rand < (100*CR))
                if ((version_de==3)) %Mutation from best candidate
                    if poblacion(a,1)<poblacion(b,1)
                        if poblacion(a,1)<poblacion(c,1)
                            trial(1,(k-1))=poblacion(a,k)+ F*(poblacion(b,k)-poblacion(c,k));
                        else
                            trial(1,(k-1))=poblacion(c,k)+ F*(poblacion(a,k)-poblacion(b,k));
                        end
                    else if poblacion(b,1)<poblacion(c,1)
                            trial(1,(k-1))=poblacion(b,k)+ F*(poblacion(c,k)-poblacion(a,k));
                        else
                            trial(1,(k-1))=poblacion(c,k)+ F*(poblacion(a,k)-poblacion(b,k));
                        end
                    end
                else
                    trial(1,(k-1))=poblacion(c,k)+ F*(poblacion(a,k)-poblacion(b,k));
                end
            else trial(1,(k-1))=poblacion(i,k);
            end
            %si nos salimos del mapa nos quedamos en el borde
            if (trial(1,(k-1))<mapmin(k-1))
                trial(1,(k-1))=mapmin(k-1);
            end
            if (trial(1,(k-1))>mapmax(k-1))
                trial(1,(k-1))=mapmax(k-1);
            end
        end

        %SELECCION
        [dist_est_3d_trial,cart_est_3d_trial]=dist_est_3d(trial,Mapa_3D,mapmax,mapmin,err_dis,num_medidas,num_barridos,incr_theta);
        %fitness_3d devuelve el error de las medidas para el punto perturbado
        error_trial=fitness_3d(dist_real_3d, cart_real_3d, dist_est_3d_trial, cart_est_3d_trial,version_fitness,err_dis,alpha,num_medidas,num_barridos);
            
        %Si el error del elemento mutado es menor, sera el integrante de la
        %nueva generacion. Existe la opcion de usar o no una banda de
        %rechazo(thresholding, en funcion de la version usada.
        
        if version_de==2 %no thresholing
            if(error_trial<poblacion(i,1)) 
                for j=2:(D+1)
                    pob_aux(i,j)=trial(1,j-1); %meto la nueva gen en una auxiliar para no mezclar gen
                end
                pob_aux(i,1)=error_trial;
            else
                for j=1:(D+1)
                    pob_aux(i,j)=poblacion(i,j); %meto la nueva gen en una auxiliar para no mezclar gen
                end
            end
        else
            if(error_trial<poblacion(i,1)*0.98) %Banda de rechazo de Thau= 0.02
                for j=2:(D+1)
                    pob_aux(i,j)=trial(1,j-1); %meto la nueva gen en una auxiliar para no mezclar gen
                end
                pob_aux(i,1)=error_trial;
            else
                for j=1:(D+1) 
                    pob_aux(i,j)=poblacion(i,j); %meto la nueva gen en una auxiliar para no mezclar gen
                end
            end
        end
    end
    
    %La poblacion pasa a la nueva generacion
    poblacion=pob_aux;
    
    %DISCARDING
    if version_de~=2
        pob_orden=sortrows(poblacion,1);
        for i=1:(int8(NP/20))
            disc=random('unid',NP/2);
            while disc==0
                disc=random('unid',NP/2);
            end
            pob_orden(NP+1-i,:)=pob_orden(disc,:);
        end
        poblacion=pob_orden;
    end 
    
    %Se busca el mejor elemento, el peor error y el global en cada
    %generacion    
    error_aux=poblacion(1,1);
    for j=1:(D+1) 
        bestmem(1,j)=poblacion(1,j);
    end
    error_med=error_aux/(num_medidas*num_barridos); %error medio por medida, en celdillas
    if ((abs(error_aux-error))<1)  %contador que detrermina un criterio de conv
        count_b=count_b+1;
    else
        count_b=0;
    end
    error=error_aux;
    error_max_aux=max(poblacion(:,1));
    if ((abs(error_max-error_max_aux))<1)   %contador que detrermina un criterio de conv
        count_a=count_a+1;
    else
        count_a=0;
    end
    error_max=error_max_aux;
    dif_errores_aux=error_max-error;
    if (abs(dif_errores_aux-dif_errores)<1)   %contador que detrermina un criterio de conv
        count_c=count_c+1;
    else
        count_c=0;
    end    
    dif_errores=dif_errores_aux;
    error_global=sum(poblacion(:,1)); 
    %CONDICION DE CONVERGENCIA, CUANDO NOS ACERCAMOS, LIMITAMOS EL AREA
    if error-error_max<1
        F=0.2;
    end
    %CONDICION DE CONVERGENCIA, SI SE HA LLEGADO DISMINUIMOS POBLACION
    if error-error_max==0
        NP=10;
    end
    
    if imp_count==5
        fprintf(1,'\n It: %f, Mejor %f, Peor: %f, Global: %f, Mejor por medida: %f \n Posicion (x, y, z, theta): [%f, %f, %f, %f] \n',count,error,error_max,error_global,error_med,poblacion(1,2),poblacion(1,3),poblacion(1,4),poblacion(1,5));
        imp_count=0;
    end
    imp_count=imp_count+1;    
    
    count=count+1;
end
end


